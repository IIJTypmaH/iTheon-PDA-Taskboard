local row_limit = 10

local SINGLETON = nil
function get_ui()
	SINGLETON = SINGLETON or pda_contacts_tab()
	return SINGLETON
end
-- Constructor.
class "pda_contacts_tab" (CUIScriptWnd)
function pda_contacts_tab:__init() super()
	self.taskboard_info = {}
	
	self.clr_red 	= utils_xml.get_color("red",true) -- GetARGB(255, 255, 1, 1)
	self.clr_green 	= utils_xml.get_color("green",true) -- GetARGB(255, 1, 255, 1)
	self.clr_yellow = utils_xml.get_color("yellow",true) -- GetARGB(255, 255, 255, 1)

	self:InitControls()
end

-- Initialise the interface.
function pda_contacts_tab:InitControls()
	self:SetWndRect(Frect():set(0, 0, 1024, 768))
	
	-- Main frame.
	local xml = CScriptXmlInit()
	xml:ParseFile("pda_contacts.xml")
	xml:InitFrame("frame1", self)
	xml:InitFrame("frame2", self)

	-- Refresh tasks button
	self.refresh_tasks_btn = xml:Init3tButton("btn_refresh_tasks", self)
	self:Register(self.refresh_tasks_btn, "refresh_tasks_btn")
	self:AddCallback("refresh_tasks_btn", ui_events.BUTTON_CLICKED, refresh_tasks_factory(self), self)

	-- Taskboard
	self.taskboard_listbox = xml:InitListBox("taskboard_listbox", self)
	self.taskboard_listbox:SetItemHeight(165)
	self:Register(self.taskboard_listbox, "taskboard_listbox")
	for i = 1, row_limit do
		self.taskboard_listbox:AddExistingItem(ui_taskboard_row(self, i, xml))
	end
end


------------------- TASKBOARD
class "ui_taskboard_row" (CUIListBoxItem)
function ui_taskboard_row:__init(parent, row, xml) super(parent, row, xml)
	local is_widescreen = true --utils_xml.is_widescreen()
	local offset_comm = is_widescreen and 36 or 49
	local offset_rank = is_widescreen and 25 or 34
	local offset_rept = is_widescreen and 51 or 68
	-- Offset of stalker's portrait and captions
	local x = is_widescreen and 40 or 55

	-- Create the components for each entry.
	parent.taskboard_info[row] = {
		["comm_field"] = self:AddTextField("", 1), 
		["comm_label"] = self:AddTextField("", 1), 
		["icon_field"] = self:AddIconField(1), 
		["name_field"] = self:AddTextField("", 1),
		["task_icon_field"] = self:AddIconField(1),
		["task_details_field"] = self:AddTextField("", 1),
		["task_full_description_field"] = self:AddTextField("", 1),
		["task_accept_btn"] = xml:Init3tButton("btn_accept_task", self),
		["task_next_btn"] = xml:Init3tButton("btn_next_task", self)
	}

	
	parent:Register(parent.taskboard_info[row].task_accept_btn, "task_accept_btn_" .. row)
	parent:AddCallback("task_accept_btn_" .. row, ui_events.BUTTON_CLICKED, accept_task_callback_factory(parent, row), parent)

	parent:Register(parent.taskboard_info[row].task_next_btn, "task_next_btn_" .. row)
	parent:AddCallback("task_next_btn_" .. row, ui_events.BUTTON_CLICKED, next_task_in_category_callback_factory(parent, row), parent)
	
	parent.taskboard_info[row].icon_field:InitTexture("ui\\ui_noise")
	parent.taskboard_info[row].icon_field:SetStretchTexture(true)
	parent.taskboard_info[row].icon_field:SetWndSize(vector2():set(64, 64))
	parent.taskboard_info[row].icon_field:SetWndPos(vector2():set(x, 0))
	parent.taskboard_info[row].icon_field:Show(false)
	
	parent.taskboard_info[row].name_field:SetFont(GetFontLetterica16Russian())
	parent.taskboard_info[row].name_field:SetWndSize(vector2():set(130, 20))
	parent.taskboard_info[row].name_field:SetWndPos(vector2():set(x, 65))
	
	parent.taskboard_info[row].comm_label:SetFont(GetFontLetterica16Russian())
	parent.taskboard_info[row].comm_label:SetWndSize(vector2():set(130, 20))
	parent.taskboard_info[row].comm_label:SetWndPos(vector2():set(x, 80))
	
	parent.taskboard_info[row].comm_field:SetFont(GetFontLetterica16Russian())
	parent.taskboard_info[row].comm_field:SetWndSize(vector2():set(130, 20))
	parent.taskboard_info[row].comm_field:SetWndPos(vector2():set(x + offset_comm, 80))

	parent.taskboard_info[row].task_icon_field:InitTexture("ui\\ui_noise")
	parent.taskboard_info[row].task_icon_field:SetStretchTexture(true)
	parent.taskboard_info[row].task_icon_field:SetWndSize(vector2():set(83, 47))
	parent.taskboard_info[row].task_icon_field:SetWndPos(vector2():set(140, 0))
	parent.taskboard_info[row].task_icon_field:Show(false)

	parent.taskboard_info[row].task_details_field:SetFont(GetFontLetterica16Russian())
	parent.taskboard_info[row].task_details_field:SetWndSize(vector2():set(103, 20))
	parent.taskboard_info[row].task_details_field:SetWndPos(vector2():set(140, 60))
	parent.taskboard_info[row].task_details_field:SetTextComplexMode(true)
	parent.taskboard_info[row].task_details_field:SetVTextAlignment(0)

	parent.taskboard_info[row].task_full_description_field:SetFont(GetFontLetterica16Russian())
	parent.taskboard_info[row].task_full_description_field:SetWndSize(vector2():set(360, 180))
	parent.taskboard_info[row].task_full_description_field:SetWndPos(vector2():set(250, 0))
	parent.taskboard_info[row].task_full_description_field:SetTextComplexMode(true)
	parent.taskboard_info[row].task_full_description_field:SetVTextAlignment(0)

	parent.taskboard_info[row].task_accept_btn:SetWndSize(vector2():set(60, 40))
	parent.taskboard_info[row].task_accept_btn:SetWndPos(vector2():set(630, 0))
	parent.taskboard_info[row].task_accept_btn:Show(false)

	parent.taskboard_info[row].task_next_btn:SetWndSize(vector2():set(60, 40))
	parent.taskboard_info[row].task_next_btn:SetWndPos(vector2():set(630, 40))
	parent.taskboard_info[row].task_next_btn:Show(false)
end

local prepared_tasks_data = {}
local current_board_state = {}
function reset_taskboard(pda_tab) 
	clear_taskboard_ui(pda_tab)
	local npc_list = get_nearby_npcs()
	trigger_generate_available_tasks(npc_list)
	prepared_tasks_data = get_prepared_task_data(npc_list)

	-- Basically let XRay do its stuff with setting up logic
	for task_effect, filtered_task_list in pairs(prepared_tasks_data) do 
		local task_data = filtered_task_list[1]
		prepare_task( task_data.npc_id, task_data.task_id )
	end
	
	-- Delay required for task details from actor message to be properly collected
	CreateTimeEvent("taskboard_delay_render", "taskboard_delay_render", 0.05, function ()
		-- Generate taskboard entries
		local i = 1
		for task_effect, filtered_task_list in pairs(prepared_tasks_data) do 
			-- Save the order of the rows and currently viewed item from the category to be able to update a single row later
			current_board_state[i] = {
				task_effect = task_effect,
				current_index = 1
			}
			update_task_entry(pda_tab, i, filtered_task_list[1])
			i = i + 1
		end
		return true
	end)
end

currently_processed_npc_id = nil -- required for fetch quest override
function prepare_task(npc_id, task_id) 
	currently_processed_npc_id = npc_id
	local on_job_descr = task_id and task_manager.task_ini:r_string_ex(task_id,"on_job_descr")
	if (on_job_descr) then 
		local cond = xr_logic.parse_condlist(db.actor,"task_manager","condlist",on_job_descr)
		if (cond) then 
			xr_logic.pick_section_from_condlist(db.actor,db.actor,cond)
		end
	end
	
	local fetch = task_id and task_manager.task_ini:r_string_ex(task_id,"fetch_descr")
	if (fetch) then
		axr_task_manager.trigger_fetch_func(task_id)
		return strformat(game.translate_string(fetch),_FETCH_TEXT or "")
	end

	currently_processed_npc_id = nil
end

function accept_task_callback_factory(pda_tab, row_index)
	return function() 
		accept_task(pda_tab, row_index)
	end
end

function accept_task(pda_tab, row_index)
	local entry_info = current_board_state[row_index]
	local task_details = prepared_tasks_data[entry_info.task_effect][entry_info.current_index]
	task_manager.get_task_manager():give_task(task_details.task_id, task_details.npc_id)
	clear_cached_data()
	reset_taskboard(pda_tab)
end

function next_task_in_category_callback_factory(pda_tab, row_index)
	return function() 
		next_task_in_category(pda_tab, row_index)
	end
end

function next_task_in_category(pda_tab, row_index)
	local entry_info = current_board_state[row_index]
	local next_task = prepared_tasks_data[entry_info.task_effect][entry_info.current_index + 1]
	
	if next_task then
		prepare_task( next_task.npc_id, next_task.task_id )

		CreateTimeEvent("next_task_delay", "next_task_delay", 0.05, function () 
			entry_info.current_index = entry_info.current_index + 1
			update_task_entry(pda_tab, row_index, next_task)
			return true
		end)
	end
end

function refresh_tasks_factory(pda_tab) 
	local refresh_disabled = false
	local function temporary_disable_refresh() 
		local delay = 2
		refresh_disabled = true
		CreateTimeEvent("reenable_refresh", "reenable_refresh", delay, function () 
			refresh_disabled = false
			return true
		end)
	end
	return function () 
		if (not refresh_disabled) then
			temporary_disable_refresh()
			clear_cached_data()
			reset_taskboard(pda_tab)
		end
	end
end

function clear_cached_data()
	z_taskboard_overrides.clear_tasks_info()
	prepared_tasks_data = {}
	current_board_state = {}
end

function clear_taskboard_ui(pda_tab) 
	-- Erase all pre-existing information.
	for i = 1, row_limit do
		if (pda_tab.taskboard_info[i]) then
			pda_tab.taskboard_info[i].comm_field:SetText("")
			pda_tab.taskboard_info[i].comm_label:SetText("")
			pda_tab.taskboard_info[i].icon_field:Show(false)
			pda_tab.taskboard_info[i].name_field:SetText("")

			pda_tab.taskboard_info[i].task_icon_field:Show(false)
			pda_tab.taskboard_info[i].task_details_field:SetText("")
			pda_tab.taskboard_info[i].task_accept_btn:Show(false)
			pda_tab.taskboard_info[i].task_full_description_field:SetText("")
			pda_tab.taskboard_info[i].task_next_btn:Show(false)
		end
	end
end

function get_nearby_npcs() 
	local radius = config.scanning_range
	local npc_list = {}
	level.iterate_nearest(db.actor:position(), radius, function (obj)
		if IsStalker(obj) and obj:alive() and obj:relation(db.actor) ~= game_object.enemy then
			table.insert(npc_list, obj)
		end
	end)
	
	-- Special case for Sidorovich and Forester.
	local function add_by_sid(sid)
		local id = story_objects.object_id_by_story_id[sid]
		if (id) then 
			local npc = db.storage[id] and db.storage[id].object 
			if (npc and db.actor:position():distance_to(npc:position()) <= radius) then 
				table.insert(npc_list, npc)
			end
		end
	end
	add_by_sid("esc_m_trader")
	add_by_sid("red_tech_forester")

	return npc_list
end

function trigger_generate_available_tasks(npc_list) 
	for _,npc in pairs(npc_list) do 
		-- Sim npcs are random roaming stalkers. Non sims are traders, mechanics, etc.
		local is_sim = string.find(npc:section(), "sim_")
		currently_processed_npc_id = npc:id()
		axr_task_manager.generate_available_tasks(npc, is_sim)
		currently_processed_npc_id = nil
	end
end

-- These tasks fire additional scripts that break the other script execution - mainly used for testing purposes
local excluded_effects = {}
function get_prepared_task_data(npc_list) 
	-- Split available tasks into categories based on their init effect
	local result = {}
	for _,stalker in pairs(npc_list) do 
		local stalker_task_list = axr_task_manager.available_tasks[stalker:id()] or {}
		for _, task_id in pairs(stalker_task_list) do
			local raw_task_effect = task_manager.task_ini:r_string_ex(task_id,"on_job_descr") or task_manager.task_ini:r_string_ex(task_id,"fetch_func")
			local task_effect = string.gmatch(raw_task_effect or "", "=(.*)%(")() or "rest"
			task_effect = normalize_task_effect(task_effect)
			if not has_value(excluded_effects, task_effect) then
				if not result[task_effect] then
					result[task_effect] = {}
				end
				table.insert(result[task_effect], {
					npc_id = stalker:id(),
					task_id = task_id,
					task_description = game.translate_string(axr_task_manager.get_task_job_description( task_id )),
				})
			end
		end
	end
	return result
end

function update_task_entry(pda_tab, i, task_details) 
	local stalker = level.object_by_id(task_details.npc_id)

	local stalker_comm = stalker:character_community()
	local stalker_icon = stalker:character_icon()
	local stalker_name = stalker:character_name()
	
	stalker_icon = stalker_icon and stalker_icon ~= "" and stalker_icon or "ui\\ui_noise"
	pda_tab.taskboard_info[i].icon_field:InitTexture(stalker_icon)
	pda_tab.taskboard_info[i].icon_field:Show(true)
	
	local name = string.gsub(stalker_name, "Junior", "Jr.")
	name = string.gsub(name, "Senior", "Sr.")
	name = string.gsub(name, "Master ", "M.")
	name = string.gsub(name, "Private", "Pvt.")
	name = string.gsub(name, "Sergeant", "Sgt.")
	name = string.gsub(name, "Lieutenant", "Lt.")
	name = string.gsub(name, "Captain", "Cpt.")
	name = string.len(name) <= 22 and name or string.sub(name, 0, 19) .. "..."
	pda_tab.taskboard_info[i].name_field:SetText(name)
	
	pda_tab.taskboard_info[i].comm_label:SetText(game.translate_string("ui_st_community") .. ": ")
	pda_tab.taskboard_info[i].comm_field:SetText(game.translate_string(stalker_comm))
	
	-- Display relation by colouring the stalker's faction name appropriately.
	if (xr_conditions.is_factions_friends(nil, nil, { stalker_comm, character_community(db.actor) })) then
		pda_tab.taskboard_info[i].comm_field:SetTextColor(pda_tab.clr_green)
	elseif (xr_conditions.is_factions_enemies(nil, nil, { stalker_comm, character_community(db.actor) })) then
		pda_tab.taskboard_info[i].comm_field:SetTextColor(pda_tab.clr_red)
	else 
		pda_tab.taskboard_info[i].comm_field:SetTextColor(pda_tab.clr_yellow)
	end

	local more_task_details = get_more_task_details(i) or {}
	pda_tab.taskboard_info[i].task_icon_field:InitTexture(more_task_details.task_icon or "ui\\ui_noise")
	pda_tab.taskboard_info[i].task_icon_field:Show(true)
	pda_tab.taskboard_info[i].task_details_field:SetText(
		(more_task_details.task_title or "") .. 
		"\\n" .. 
		(string.gsub(more_task_details.task_details or "", "\\n ", "\\n"))
	)
	pda_tab.taskboard_info[i].task_full_description_field:SetText(task_details.task_description or "")
	pda_tab.taskboard_info[i].task_accept_btn:Show(true)
	pda_tab.taskboard_info[i].task_next_btn:Show(has_more_task_in_category(i))
end

function has_more_task_in_category(i) 
	local entry_info = current_board_state[i]
	local next_task = prepared_tasks_data[entry_info.task_effect][entry_info.current_index + 1]
	-- To do: add condition for the button to not show at all
	return not not next_task
end

local processed_tasks_with_no_info = 0
-- This function is a pure fuckery and crime against the code, but there's literally no other way to couple the
-- task data with the details received through overridden actor method.
function get_more_task_details(i)
	local entry_info = current_board_state[i]
	if entry_info.current_index == 1 then
		-- If no new task has been requested for a given category, index of details will be the same as the index of row (or at least I didn't observe any
		-- deviations from that rule for now)
		if(entry_info.task_effect ~= "rest") then
			return z_taskboard_overrides.tasks_info[i - processed_tasks_with_no_info]
		else 
			-- Some tasks do not have detailed info - this has to be taken into consideration when fetching info for them and for the next tasks
			processed_tasks_with_no_info = processed_tasks_with_no_info + 1
		end
	else
		-- If new task has been requested, the details will be appended at the end of the array, so we can easily read them
		return z_taskboard_overrides.tasks_info[#z_taskboard_overrides.tasks_info]
	end
end

function has_value (tab, val)
    for index, value in ipairs(tab) do
        if value == val then
            return true
        end
    end

    return false
end

function normalize_task_effect(task_effect) 
	-- Some effects have different names even though they perform pretty much the same actions as the generic/simulation task effects
	-- Those should be pushed into the same category to prevent queued actor messages from being discarded
	local normalizer = {
		setup_supplies_fetch_task_lostzone_patch = "setup_fetch_task",
		setup_generic_fetch_task = "setup_fetch_task",
		drx_sl_create_quest_stash = "setup_fetch_task"
	}
	return normalizer[task_effect] or task_effect
end

local function load_defaults()
	local t = {}
	local op = pda_taskboard_mcm.op
	for i, v in ipairs(op.gr) do
		if v.def ~= nil then
			t[v.id] = v.def
		end
	end
	return t
end
-- Default config
config = load_defaults()

local function load_settings()
	config = load_defaults()
	if ui_mcm then
		for k, v in pairs(config) do
			config[k] = ui_mcm.get("pda_taskboard/" .. k)
		end
	end
end

function on_game_start()
	RegisterScriptCallback("on_game_load", load_settings)
	RegisterScriptCallback("on_option_change", load_settings)
end
